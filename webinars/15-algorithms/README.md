background-image: url(../img/title.svg)

---

background-image: url(../img/rec.svg)

---
background-image: url(../img/topic.svg)

.topic[Алгоритмы и структуры данных]
.tutor[Родион Ступников]
.tutor_desc[Software Engineer]

---

background-image: url(../img/rules.svg)

---

# Цели занятия

* понять что такое алгоритм и научиться его оценивать
* разобраться в базовых структурах данных и научиться их применять

---

# Что такое алгоритм

Алгоритм - это набор инструкций (шагов), который решает определенную задачу.

Любой код так описывает по сути алгоритм.

---

# Как оценить алгоритм

Для оценки эффективности алгоритма и его потребления памяти мы используем O-нотацию.

Пример: `O(N)`

Где `N` - количество элементов в множестве

---


# Слайсы/Массивы

* Чтение произвольного элемента из массива: `O(1)`. Память: `O(1)`
* Обновление произвольного элемента в массиве: `O(1)`. Память: `O(1)`
```go
slice[i] = 10
```
* Поиск определенного элемента в массиве: `O(N)`. Память: `O(1)`
```go
for _, val := range slice {
	    if val == targetVal {
		    return val
	    }
}
```
* Обратите внимание, что мы оцениваем всегда худший сценарий в O-нотации

---

# Какие типы алгоритмов бывают

* `O(1)` - константное время выполнение (операции в массивах, хеш-мапах)
* `O(log N)` - логарифмическое время выполнения (Поиск по дереву)
* `O(N)` - линейное время выполнения (Сложение элементов в массиве)

---
# Какие типы алгоритмов бывают

* `O(N*log N)` - алгоритм сортировки QuickSort, MergeSort
* `O(N^2)` - квадратичная сложность: сортировка пузырьком, многие алгоритмы основанные на брутфорсе
* `O(2^N)` - эспоненциальная сложность: разные комбинаторные алгоритмы, генерация сочетаний
* `O(!N)` - факториальная сложность: рекурсивное вычисление чисел Фибоначчи

---
# Стек 

Структура данных типа: LIFO - Last In, First Out. 

То есть элемент, который пришел в нее последний, будет забран первым
.center-image[
![](img/stack.png)
]

---
# Стек

```go

type Stack struct {
    items []interface{}
}
// Push добавляет элемент в вершину стека.
func (s *Stack) Push(item interface{}) {
    s.items = append(s.items, item) // O(1)
}

// Pop удаляет и возвращает элемент с вершины стека.
func (s *Stack) Pop() interface{} {
    if len(s.items) == 0 {
        return nil
    }

    index := len(s.items) - 1
    item := s.items[index]
    s.items = s.items[:index] // Удаляем элемент из среза
    return item // O(1)
}


```
https://go.dev/play/p/1Oubr7jUibE

---
понятие алгоритмической сложности;
структуры данных массив (простой и динамический), матрица, список, стек, очередь;

---

background-image: url(../img/questions.svg)

---

background-image: url(../img/poll.svg)

---

background-image: url(../img/next_webinar.svg)
.announce_date[1 января]
.announce_topic[Тема следующего вебинара]

---
background-image: url(../img/thanks.svg)

.tutor[Лектор]
.tutor_desc[Должность]
