background-image: url(../img/title.svg)

---

background-image: url(../img/rec.svg)

---
background-image: url(../img/topic.svg)

.topic[Алгоритмы и структуры данных. Часть 2]
.tutor[Родион Ступников]
.tutor_desc[Software Engineer]

---

background-image: url(../img/rules.svg)

---
# Цели занятия

* изучить структуры данных такие как: множество, дерево (в т.ч. бинарное), граф, хеш таблица
* изучить эффективные алгоритмы поиска
* изучить случаи, когда приведенные выше структуры данных могут оказаться полезны

---
# Хеш таблица

В языке Go уже есть стандартная структура данных map, которая позволяет за константное 
время находить произвольный элемент по его ключу.

Map гарантирует, что все ключи внутри нее уникальны.



.center-image[
![](img/map.png)
]

---
# Хеш таблица

Значением в хеш-таблице могут быть любые типы

А вот ключами: любые не ссылочные типы

```go
map[int][]int //ok
map[bool]string // ok
map[string]map[string]string //ok, может хранить внутри сложные объекты
map[[10]int64]float64 //ok
map[[]int]float64 // а вот так нельзя, []int - ссылочный тип
map[SomeStruct]*string //ok, если внутри нет ссылочных типов
map[interface{}]string //ok,  в интерфейс можно передать все, что не содержит ссылочные типы
map[[10]int64]interface{} //ok 
map[*int]bool - // так нельзя, *int - ссылочный тип
map[map[int]int]int // так нельзя, сама map - тоже ссылочный тип
map[interface{}]interface{} // ok
```

---
# Хеш таблица

Map - это ссылочный тип данных (как слайс). 
Их всегда нужно инициализировать перед использованием!

Ниже показаны способы создания map:

* С выделением емкости под будущие значения
```go
m := make(map[string]int, 10)
```

* С заданными значениями:
```go
m := map[string]int{
	"виталий": 31,
	"артем": 20,
	"петр": 25,
}
```

Еще один пример:
https://go.dev/tour/moretypes/20

---
# Хеш таблица

Чтение по ключу из хеш-таблицы: сложность O(1)

```go
val := m["артем"]
```
Если значение не существует в map, будет возвращено Zero Value.

Мы также можем вторым аргументом вычитать булевый флаг isExist.
```go
val, isExist := m["артем"]
```
В основном это нужно в сценариях, когда мы хотим узнать, 
действительно ли там записан ключ с ZeroValue,  или такого ключа там нет?

---
# Хеш таблица

Запись по ключу в хеш таблицу: сложность O(1)
```go
m["артем"] = 10
```

---
# Хеш таблица

С помощью оператора delete можно удалять значения из хеш-таблицы. 
```go
delete(m, "artem")
```
Как думаете, какая сложность у операции в O-нотации?

Пример внесения изменений в map:
https://go.dev/tour/moretypes/22

---
# Хеш таблица

Перебор всех ключей и значений в map

```go
for key, value := range m {
	fmt.Println(key, value)
}
```
Обратите внимание, что ключи и значения будут перебраны в случайном порядке.

https://go.dev/play/p/_8Yj1LON1ne

---
# Хеш таблица

Как она работает внутри:

.center-image[
![](img/map_detail.png)
]

---
# Хеш таблица

Больше можно узнать тут:
https://habr.com/ru/articles/457728/

---
# Множество

Множество - это как правило набор уникальных значений. 
В Go множество как правило реализуется через хеш-таблицу.

.

.center-image[
![](img/set.png)
]

---

# Множество

Реализация

```go
type Set struct {
	data map[int]struct{}
}

// Создать новое множество
func NewSet() *Set {
	s := &Set{
		data: make(map[int]struct{}),
	}
	return s
}

// Добавить элемент в множество
func (s *Set) Append(item int) {
    s.data[item] = struct{}{}
}

```

---
# Множество

Множествами удобно моделировать объекты из реального мира.

Допустим, у нас есть студенты, которые могут относиться как к множеству, записаны на курс Go,
так и к множеству, которые записаны на курс по Алгоритмам.

---

# Множество

Операция объединения:

.center-image[
![](img/set_add.png)
]

Что будет со сложностью?
Сколько нужно памяти?

---

# Множество

Операция объединения:

```go
func (s *Set) Add(other *Set) *Set {
    result := NewSet()

    // Добавляем элементы из текущего множества
    for item := range s.data {
        result.Append(item)
    }

    // Добавляем элементы из другого множества
    for item := range other.data {
        result.Append(item)
    }

    return result
}
```

Что будет со сложностью?
Сколько нужно памяти?

---
# Множество

Операция пересечения:

.center-image[
![](img/set_intersect.png)
]

Что будет со сложностью?
Сколько нужно памяти?


---
# Множество

Операция пересечения:

```go
// Пересечение множеств
func (s *Set) Intersect(other *Set) *Set {
	result := NewSet()
	for item := range s.data {
		if other.Contains(item) {
			result.Append(item)
		}
	}
	return result
}

// Проверить, содержит ли множество элемент
func (s *Set) Contains(item int) bool {
    _, found := s.data[item]
    return found
}
```
Что будет со сложностью?
Сколько нужно памяти? 
Как можно оптимизировать?

---
# Множество

Потребление памяти при операции пересечения: O(min(n, m)) ~= O(N)

---
# Множество

Операция вычитания:

---

множество, дерево (в т.ч. бинарное), граф

---

background-image: url(../img/questions.svg)

---

background-image: url(../img/poll.svg)

---

background-image: url(../img/next_webinar.svg)
.announce_date[1 января]
.announce_topic[Тема следующего вебинара]

---
background-image: url(../img/thanks.svg)

.tutor[Лектор]
.tutor_desc[Должность]
