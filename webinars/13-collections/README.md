background-image: url(../img/title.svg)

---

background-image: url(../img/rec.svg)

---
background-image: url(../img/topic.svg)

.topic[Массивы и слайсы, мапы]
.tutor[Романовский Алексей]
.tutor_desc[Разработчик в компании Resolver Inc.]

---

background-image: url(../img/rules.svg)

---

# Краткое содержание
* массивы и слайсы, мапы (arrays, slices, maps);
* длина и ёмкость;
* внутренняя структура слайсов и словарей;
* различные способы итерации;
* распространённые ошибки и затруднения

---


# Массивы

```go
var arr [256]int         // фиксированная длина

var arr [10][10]string   // может быть многомерным

arr := [...]int{1, 2, 3} // автоматический подсчет длины

arr := [10]int{1, 2, 3, 4, 5}
```

---

# Массивы: операции

```go
v := arr[1] // чтение

arr[3] = 1  // запись

len(arr)    // длина массива

arr[2:4]    // получение слайса
```

Массивы передаются по значению

<br>

### Пример: https://goplay.space/#efOzTXkKKKL

---

# Слайсы

Слайсы — это те же "массивы", но переменной длины.

<br/>
Создание слайсов:

```go
var s []int  // не-инициализированный слайс, nil

s := []int{} // с помощью литерала слайса

s := make([]int, 3) // с помощью функции make, s == {0,0,0}
s := make([]int, 3, 10) // то же, но вручную управляем ёмкостью (позже)
```

---

# Устройство слайсов

Внутри слайс - это ссылка на определённую область массива.

```go
	a := [3]int{1, 2, 3}
	s1 := a[0:2]
	s2 := a[1:3]
	fmt.Println(a, s1, s2)
    // [1 2 3] [1 2] [2 3]


	s1[1] = 9
	fmt.Println(a, s1, s2)
    // [1 9 3] [1 9] [9 3]
```


### Пример: https://goplay.space/#6i3gMUTmckq

### Ссылки:
* https://blog.golang.org/go-slices-usage-and-internals

---
# Устройство слайсов

Иногда массив под слайслом нам доступен, а иногда нет.

```go
func main() {
    a := [3]int{1, 2, 3}
    s1 := a[0:2] // массив создан нами

    s2 := []int{1, 2, 3} // массив создан за нас
}
``` 

---

# Слайсы: операции

Почти те же самые, что и для массивов.

```go
v := s[1] // чтение

s[3] = 1  // запись

len(s)    // длина слайса

cap(s)    // ёмкость слайса (позже)

s[2:4]    // получение под-слайса
```

---

# Слайсы: добавление элементов

```go
s = append(s, 1)       // добавляет 1 в конец слайса

s = append(s, 1, 2, 3) // добавляет 1, 2, 3 в конец слайса

s = append(s, s2...)   // добавляет содержимое слайса s2 в конец s
```

```go
var s []int            // s == nil
s = append(s, 1)       // s == {1} append умеет работать с nil-слайсами
```

Append всегда возвращает новый слайс, но иногда массив под слайсом остаётся тот же.

### Пример: https://goplay.space/#NXZWljF65zd

---

# Слайсы: реаллокация

Реаллокация - это пересоздание массива под слайсом. Происходит, когда в слайс добавляется элемент, а его ёмкости не хватает;

<br>

Массив, который использует слайс может быть больше, чем нужно.
Это позволяет добавлять элементы в конец слайса без пересоздания этого массива (реаллокации).

<br>

*Ёмкость* слайса - это размер этого массива, с запасом,<br>
а *длина* - это количество элементов, которые в нём используются.


```go
s := make([]int, 0, 3) // s = []   s' == [0,0,0]
s = append(s, 1)        // s = [1], s' == [1,0,0]
```

### Пример1: https://goplay.space/#9P0nen3q6RH
### Пример2: https://goplay.space/#WtaZbvW4AeB

---

# Получение под-слайса (нарезка)

`s[i:j]` — возвращает под-слайс, с `i` -ого элемента включительно, по `j` -ый не влючительно.

Длинна нового слайса будет `j-i`.

```go
s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

s2 := s[3:5] // ?

s2 := s[3:]  // ?

s2 := s[:5]  // ?

s2 := s[:]   // копия s (shallow)
```

### Пример: https://goplay.space/#6nHKyMNjQbO

---

# Распространённые ошибки и затруднения

* несколько слайсов могут ссылаться на один массив
* удаление элементов слайса: `s = append(s[:i], s[i+1:]...)` где `i` - индекс элемента для удаления
    * ещё можно через копирование
* Использование Make `make([]int, <len>, <cap>)`

<br>

### Ссылки:
* https://github.com/golang/go/wiki/SliceTricks

---

# Слайсы: итерирование


```go
// Индекс и значение
for i, v := range s {
  ...
}
```
```go
// Только индекс
for i := range s {
  ...
}
```
```go
// Только значение
for _, v := range s {
  ...
}
```

---
# Словари (map)

* Отображение ключ => значение;
* Реализованы как хэш-таблицы;
* Аналогичные типы в других языках: 
    * в Python — `dict`, 
    * в JavaScript — `Object`, 
    * в Java — `HashMap`, 
    * в C++ — `unordered_map`,
    * в C# - `Dictionary<Tkey,TValue>`;
* Быстро ищут значение по ключу. 

---

# Словари: cоздание

```go
var cache map[string]string  // не-инициализированный словарь, nil

cache := map[string]string{} // с помощью литерала, len(cache) == 0

cache := map[string]string{  // литерал с первоначальным значением
	"one":   "один",
	"two":   "два",
	"three": "три",
}

cache := make(map[string]string)      // тоже что и map[string]string{}

cache := make(map[string]string, 100) // заранее выделить память
                                      // на 100 ключей
```

---

# Словари: операции

```go
value := cache[key]     // получение значения (не паникует в современном Go),

value, ok := cache[key] // получить значение, и флаг того что ключ найден

_, ok := cache[key]     // проверить наличие ключа в словаре

cache[key] = value      // записать значение в инициализированный(!) словарь

delete(cache, key)      // удалить ключ из словаря, работает всегда
```

В Go нет функций, возвращающих списки ключей и значений словаря. 

<br>
<br>

### Ссылки:
* [Подробное описание, оф.](https://blog.golang.org/go-maps-in-action)
* [Внутреннее устройство, статья 1](https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html)
* [Внутреннее устройство, статья 2](https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics)


---

# Словари: требования к ключам

Ключом может быть любой тип данных, который можно сравнивать `==` :
* строки, числовые типы, bool каналы (chan);
* интерфейсы;
* указатели;
* структуры или массивы содержащие сравнимые типы;
* alias-ы.

```go
type User struct {
  Name string
  Host string
}
var cache map[User][]Permission
```

<br>

### Ссылки:
* https://golang.org/ref/spec#Comparison_operators

---
# Словари: порядок ключей

* Порядок чтения ключей из словаря не определён (случаен, может меняться в разных версиях Го).
* Что будет, если удалить ключ во время итерирования?
* Что будет, если добавить ключ во время итерирования?

### Менять коллекцию во время её итерирования — плохая идея!

### Пример: https://goplay.space/#SmisQCUpCGb

---

# Использование Zero Values

Для слайсов и словарей, zero value — это nil .

<br/>
С таким значением будут работать функции и операции читающие данные, например:

```go
var seq []string             // nil
var cache map[string]string  // nil
l := len(seq)       // 0
c := cap(seq)       // 0
l := len(cache)     // 0
v, ok := cache[key] // "", false
```

Для слайсов будет так же работать `append`
```go
var seq []string             // nil
seq = append(seq, "hello")   // []string{"hello"}
```

---

# Использование Zero Values

Вместо:
```go
hostUsers := make(map[string][]string)
for _, user := range users {
  if _, ok := hostUsers[user.Host]; !ok {
    hostUsers[user.Host] = make([]string)
  }
  hostUsers[user.Host] = append(hostUsers[user.Host], user.Name)
}
```

Можно:
```go
hostUsers := make(map[string][]string)
for _, user := range users {
  hostUsers[user.Host] = append(hostUsers[user.Host], user.Name)
}
```

---
# Big picture

* массивы - по значению, слайсы, мапы - по ссылке;
* слайсы - это ссылки на массивы;
* у слайсов есть длина и ёмкость, может случиться реаллокация;
* мапы - это хэш-таблицы - быстро ищут по ключу;
* порядок ключей в мапе не определён;

---

background-image: url(../img/questions.svg)

---

background-image: url(../img/poll.svg)

---

background-image: url(../img/next_webinar.svg)
.announce_date[21 Сентября]
.announce_topic[Строки и руны]

---
background-image: url(../img/thanks.svg)

.tutor[Романовский Алексей]
.tutor_desc[Разработчик в компании Resolver Inc.]
